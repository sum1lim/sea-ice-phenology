#!/usr/bin/env python3
import ee
import argparse
import csv
import math
import pandas as pd
from tqdm import tqdm
from statistics import mean


def getQABits(number, start, end):
    i = 0
    bit_mask = 0
    while i < 16:
        if not i < start and not i > end:
            bit_mask += 2 ** i
        i += 1

    return number & bit_mask


def id_pixel_dict(pixels, bands):
    if type(bands) == str:
        bands = [bands]

    ret_dicts = [{} for _ in range(len(bands))]
    try:
        pix_li = pixels.getInfo()
    except ee.ee_exception.EEException:
        return ret_dicts
    id_idx = pix_li[0].index("id")
    band_idx_li = [pix_li[0].index(band) for band in bands]
    del pix_li[0]

    for pixel in tqdm(pix_li):
        key = pixel[id_idx]
        for i, band_idx in enumerate(band_idx_li):
            if pixel[band_idx] != None:
                ret_dicts[i][key] = pixel[band_idx]

    if len(ret_dicts) == 1:
        return ret_dicts[0]
    else:
        return tuple(ret_dicts)


def get_timeseries(lon, lat):
    center = ee.Geometry.Point(lon, lat)
    buff = ee.Geometry.Point(lon, lat).buffer(125 * (1 / math.tan(math.pi / 8)))
    window = [center] + [
        ee.Geometry.Point(
            [
                buff.coordinates().getInfo()[0][i][0],
                buff.coordinates().getInfo()[0][i][1],
            ]
        )
        for i in range(2, 24, 3)
    ]

    output_dict = {}
    for point in window:

        landsat = (
            ee.ImageCollection("LANDSAT/LC08/C02/T1_TOA")
            .filterDate(args.start_date, args.end_date)
            .select(["B4", "QA_PIXEL"], ["B1", "QA"])
            .getRegion(point, 0.1)
        )
        landsat_B1_dict, landsat_qa_dict = id_pixel_dict(landsat, ["B1", "QA"])

        for k, v in landsat_qa_dict.items():
            cloud_qa = getQABits(v, 3, 3)
            if cloud_qa == 0:
                date = k.split("_")[-1]
                if k in landsat_B1_dict.keys():
                    if k.replace("_", "-") in output_dict.keys():
                        output_dict[f"{date[0:4]}-{date[4:6]}-{date[6:8]}"] += [
                            landsat_B1_dict[k]
                        ]
                    else:
                        output_dict[f"{date[0:4]}-{date[4:6]}-{date[6:8]}"] = [
                            landsat_B1_dict[k]
                        ]

        modis = (
            ee.ImageCollection("MODIS/006/MOD09GQ")
            .filterDate(args.start_date, args.end_date)
            .select(["sur_refl_b01"], ["B1"])
            .getRegion(point, 0.1)
        )
        modis_qa = (
            ee.ImageCollection("MODIS/006/MOD09GA")
            .filterDate(args.start_date, args.end_date)
            .select("state_1km", "SolarZenith")
            .getRegion(point, 0.1)
        )

        modis_qa_dict, solar_dict = id_pixel_dict(
            modis_qa, ["state_1km", "SolarZenith"]
        )
        modis_B1_dict = id_pixel_dict(modis, ["B1"])

        for k, v in modis_qa_dict.items():
            cloud_qa = getQABits(v, 0, 1)
            if (cloud_qa == 0 or cloud_qa == 3) and solar_dict[k] <= 8600:
                if k in modis_B1_dict.keys():
                    if k.replace("_", "-") in output_dict.keys():
                        output_dict[k.replace("_", "-")] += [modis_B1_dict[k] / 10000]
                    else:
                        output_dict[k.replace("_", "-")] = [modis_B1_dict[k] / 10000]

    return output_dict


def main(args):
    ee.Initialize()
    if args.coords_csv:
        locations = pd.read_csv(args.coords_csv[0])
        for index, row in locations.iterrows():
            print(row[args.coords_csv[1:4]])
            output_dict = get_timeseries(
                row[args.coords_csv[1]], row[args.coords_csv[2]]
            )

            with open(
                f"{args.output}/{row[args.coords_csv[3]].replace(' ', '_')}.csv", "w"
            ) as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(["system:time_start", "B1"])
                for k in sorted(output_dict.keys()):
                    writer.writerow([k, mean(output_dict[k])])

    elif args.coords:
        output_dict = get_timeseries(args.coords[0], args.coords[1])

        with open(f"{args.output}", "w") as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(["system:time_start", "B1"])
            for k in sorted(output_dict.keys()):
                writer.writerow([k, mean(output_dict[k])])


if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--coords",
        nargs=2,
        type=float,
        help="Area of Interest (AOI) defined by lon, lat coordiates",
        required=False,
    )
    parser.add_argument(
        "--coords-csv",
        nargs=4,
        type=str,
        help="Input file (CSV) followed by column names of lon, lat and label",
        required=False,
    )
    parser.add_argument(
        "--start-date",
        type=str,
        help="YYYY-MM-DD",
        required=True,
    )
    parser.add_argument(
        "--end-date",
        type=str,
        help="YYYY-MM-DD",
        required=True,
    )
    parser.add_argument(
        "--output",
        type=str,
        help="Output file/dir path",
        required=False,
    )

    args = parser.parse_args()

    main(args)
