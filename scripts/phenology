#!/usr/bin/env python3
import argparse
import os
from difflib import context_diff
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import statsmodels.api as sm
from sklearn.linear_model import LinearRegression
from scipy.stats import pearsonr
from scipy.signal import argrelextrema
from sea_ice_phenology.utils import interQuantileMask, hampel_filter

pd.options.mode.chained_assignment = None
lowess = sm.nonparametric.lowess


def melt_freeze_season(dataframe):
    dataframe["season_idx"] = dataframe["filtered"].copy()

    dataframe["season_idx"].mask(dataframe["season_idx"] < 0.15, -3, inplace=True)
    dataframe["season_idx"].mask(
        (dataframe["season_idx"] > 0.15) & (dataframe["season_idx"] < 0.6),
        0,
        inplace=True,
    )
    dataframe["season_idx"].mask(dataframe["season_idx"] > 0.6, 3, inplace=True)

    return dataframe


def slope_diff_method(dataframe, band):
    # Hampel Filtering
    sequence, _ = hampel_filter(dataframe[band], 9, n_sigmas=1)
    # Lowess Filtering
    sequence = pd.Series(
        lowess(
            exog=sequence.index.astype(int),
            endog=sequence,
            return_sorted=False,
            frac=5 / len(sequence),
        )
    )
    sequence.index = dataframe.index
    filtered = pd.Series(sequence, name="filtered")
    dataframe = pd.concat([dataframe, filtered], axis=1)

    subset_length = 15
    anomaly_li = [0 for _ in range(subset_length)]
    median_diff_li = [0 for _ in range(subset_length)]
    idx = subset_length
    while idx < dataframe.shape[0]:
        left = sequence[idx - subset_length : idx].dropna()
        right = sequence[idx : idx + subset_length].dropna()
        notna_1 = sequence[idx - subset_length : idx].notna()
        index_1 = notna_1[notna_1].index.astype(np.int64)
        notna_2 = sequence[idx : idx + subset_length].notna()
        index_2 = notna_2[notna_2].index.astype(np.int64)

        if (
            left.shape[0] > 2 * subset_length // 3
            and right.shape[0] > 2 * subset_length // 3
        ):
            left_reg = (
                LinearRegression()
                .fit(np.array([left.index]).reshape(-1, 1), left)
                .coef_[0]
            )
            right_reg = (
                LinearRegression()
                .fit(np.array([right.index]).reshape(-1, 1), right)
                .coef_[0]
            )
            left_r, _ = pearsonr(index_1, left)
            right_r, _ = pearsonr(index_2, right)

            anomaly_li.append((left_reg * left_r - right_reg * right_r))
            median_diff_li.append(np.sign(left.median() - right.median()))
        else:
            anomaly_li.append(0)
            median_diff_li.append(0)

        idx += 1

    tmp = dataframe.copy()
    tmp["anomaly"] = anomaly_li
    tmp["median_diff"] = median_diff_li

    maxima = argrelextrema(tmp["anomaly"].to_numpy(), np.greater, order=20)
    minima = argrelextrema(tmp["anomaly"].to_numpy(), np.less, order=20)
    tmp["maxima"] = [1 if i in maxima[0] else 0 for i in range(len(tmp))]
    tmp["minima"] = [1 if i in minima[0] else 0 for i in range(len(tmp))]

    tmp["anomaly"] = interQuantileMask(tmp["anomaly"], low=-1, middle=0, high=1)

    # Divide timeseries into freezing, transition and melt seasons
    tmp = melt_freeze_season(tmp)

    # Detect dates with high probability of phenology
    tmp["phenology"] = (
        tmp["anomaly"] * tmp["maxima"]
        + tmp["anomaly"] * tmp["minima"]
        + tmp["season_idx"]
    )

    # Define names for phenology
    tmp["phenology"].mask(
        (tmp["phenology"] == 2) & (tmp["median_diff"] > 0), "MO", inplace=True
    )
    tmp["phenology"].mask(
        (tmp["phenology"] == 1) & (tmp["median_diff"] > 0), "PO", inplace=True
    )
    tmp["phenology"].mask(
        (tmp["phenology"] == -1) & (tmp["median_diff"] > 0), "PD", inplace=True
    )
    tmp["phenology"].mask(
        (tmp["phenology"] == -2) & (tmp["median_diff"] > 0), "OW", inplace=True
    )
    tmp["phenology"].mask(
        (tmp["phenology"] == -4) & (tmp["median_diff"] < 0), "FO", inplace=True
    )

    tmp["phenology"].mask(
        tmp["phenology"].astype(str).str.isalpha() == False, "", inplace=True
    )

    return tmp


def main(args):
    if not os.path.isfile(args.input):
        return

    ts_df = pd.read_csv(args.input, thousands=",")
    ts_df["system:time_start"] = pd.to_datetime(ts_df["system:time_start"])
    ts_df = ts_df.groupby("system:time_start").mean()

    filename = f"{args.input.split('/')[-1].split('_interpolate')[0]}_phenology"
    for band in ts_df.columns:
        if band.endswith("interpolate") == False:
            continue

        tmp = ts_df.copy()
        tmp["Date"] = tmp.index

        tmp = slope_diff_method(tmp, band)

        # Maker for plotting
        tmp["marker"] = tmp["phenology"].copy()
        tmp["marker"].mask(tmp["marker"] != "", "Phenology", inplace=True)

        sns.set_style("dark")
        fig, ax = plt.subplots(figsize=(20, 4))

        p1 = sns.lineplot(data=tmp, x="Date", y="filtered", color="grey", ax=ax)
        p2 = sns.scatterplot(
            data=tmp,
            x="Date",
            y=band,
            hue="phenology",
            palette="tab10",
            size="marker",
            sizes=(30, 5),
            ax=ax,
        )
        fig.canvas.manager.set_window_title(filename)

        plt.grid()
        plt.show()

        ts_df[f"{band.split('_interpolate')[0]}_phenology"] = tmp["phenology"]

    ts_df.to_csv(f"{args.output}/{filename}.csv")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--input",
        nargs="+",
        type=str,
        help="Path to time-series data file (csv)",
        required=True,
    )
    parser.add_argument(
        "--type",
        type=str,
        choices=["slope-diff"],
        default="slope-diff",
        help="Phenology detection method",
    )
    parser.add_argument(
        "--output",
        type=str,
        help="Output dir path",
        required=True,
    )

    args = parser.parse_args()
    if type(args.input) == list:
        inputs = args.input[:]
        for ip in inputs:
            args.input = ip
            main(args)
    else:
        main(args)
